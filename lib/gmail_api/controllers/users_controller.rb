# This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).

module GmailApi
  class UsersController < BaseController
    @@instance = UsersController.new
    # Singleton instance of the controller class
    def self.instance
      @@instance
    end

    # Set up or update a push notification watch on the given user mailbox.
    # @param [WatchRequest] body Required parameter: Example: 
    # @param [String] user_id Required parameter: The user's email address. The special value me can be used to indicate the authenticated user.
    # @param [String] alt Optional parameter: Data format for the response. (Acceptable values are: "json")
    # @param [String] fields Optional parameter: Selector specifying which fields to include in a partial response.
    # @param [String] key Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    # @param [String] oauth_token Optional parameter: OAuth 2.0 token for the current user.
    # @param [Boolean] pretty_print Optional parameter: Returns response with indentations and line breaks.
    # @param [String] quota_user Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    # @param [String] user_ip Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    # @return WatchResponse response from the API call
    def create_watch(body, 
                     user_id, 
                     alt = 'json', 
                     fields = nil, 
                     key = nil, 
                     oauth_token = nil, 
                     pretty_print = true, 
                     quota_user = nil, 
                     user_ip = nil)

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/{userId}/watch'
      _query_builder = APIHelper.append_url_with_template_parameters _query_builder, {
        'userId' => user_id
      }
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'alt' => alt,
        'fields' => fields,
        'key' => key,
        'oauth_token' => oauth_token,
        'prettyPrint' => pretty_print,
        'quotaUser' => quota_user,
        'userIp' => user_ip
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # prepare and execute HttpRequest
      _request = @http_client.post _query_url, headers: _headers, parameters: body.to_json
      OAuth2.apply(_request)
      _context = execute_request(_request)
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return WatchResponse.from_hash(decoded)
    end

    # Stop receiving push notifications for the given user mailbox.
    # @param [String] user_id Required parameter: The user's email address. The special value me can be used to indicate the authenticated user.
    # @param [String] alt Optional parameter: Data format for the response. (Acceptable values are: "json")
    # @param [String] fields Optional parameter: Selector specifying which fields to include in a partial response.
    # @param [String] key Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    # @param [String] oauth_token Optional parameter: OAuth 2.0 token for the current user.
    # @param [Boolean] pretty_print Optional parameter: Returns response with indentations and line breaks.
    # @param [String] quota_user Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    # @param [String] user_ip Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    # @return void response from the API call
    def create_stop(user_id, 
                    alt = 'json', 
                    fields = nil, 
                    key = nil, 
                    oauth_token = nil, 
                    pretty_print = true, 
                    quota_user = nil, 
                    user_ip = nil)

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/{userId}/stop'
      _query_builder = APIHelper.append_url_with_template_parameters _query_builder, {
        'userId' => user_id
      }
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'alt' => alt,
        'fields' => fields,
        'key' => key,
        'oauth_token' => oauth_token,
        'prettyPrint' => pretty_print,
        'quotaUser' => quota_user,
        'userIp' => user_ip
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare and execute HttpRequest
      _request = @http_client.post _query_url
      OAuth2.apply(_request)
      _context = execute_request(_request)
      validate_response(_context)
    end

    # Gets the current user's Gmail profile.
    # @param [String] user_id Required parameter: The user's email address. The special value me can be used to indicate the authenticated user.
    # @param [String] alt Optional parameter: Data format for the response. (Acceptable values are: "json")
    # @param [String] fields Optional parameter: Selector specifying which fields to include in a partial response.
    # @param [String] key Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    # @param [String] oauth_token Optional parameter: OAuth 2.0 token for the current user.
    # @param [Boolean] pretty_print Optional parameter: Returns response with indentations and line breaks.
    # @param [String] quota_user Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    # @param [String] user_ip Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    # @return Profile response from the API call
    def get_profile(user_id, 
                    alt = 'json', 
                    fields = nil, 
                    key = nil, 
                    oauth_token = nil, 
                    pretty_print = true, 
                    quota_user = nil, 
                    user_ip = nil)

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/{userId}/profile'
      _query_builder = APIHelper.append_url_with_template_parameters _query_builder, {
        'userId' => user_id
      }
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'alt' => alt,
        'fields' => fields,
        'key' => key,
        'oauth_token' => oauth_token,
        'prettyPrint' => pretty_print,
        'quotaUser' => quota_user,
        'userIp' => user_ip
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return Profile.from_hash(decoded)
    end
  end
end
